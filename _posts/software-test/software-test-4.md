---
title: 【软件测试基础】- [4].白盒测试设计方法
date: 2018-05-05 19:12:18
updated: 2018-05-05 19:12:18
tags: ['白盒测试','白盒测试设计','白盒设计','逻辑覆盖','路径覆盖','条件覆盖', '基本路径']
categories: 
 - 软件测试
---

# 基本概念

白盒测试（white-box testing，又称逻辑驱动测试，结构测试）是把测试对象看作一个打开的盒子。利用白盒测试法进行动态测试时，需要测试软件产品的内部结果和处理过程，不需要测试软件产品的功能。

# 方法分类
<table border="1">
   <tr>
      <th>测试方法</th>
      <th>分类</th>
      <th>说明</th>
   </tr>
   <tr>
      <td rowspan="6">逻辑覆盖</td>
      <td>语句覆盖</td>
      <td>每条语句至少执行一次</td>
   </tr>
   <tr>
      <td>判定覆盖</td>
      <td>每个判定的每个分支至少执行一次</td>
   </tr>
   <tr>
      <td>条件覆盖</td>
      <td>每个判定的每个条件应取到各种可能的值</td>
   </tr>
   <tr>
      <td>判定/条件覆盖</td>
      <td>同时满足判定覆盖和条件覆盖</td>
   </tr>
   <tr>
      <td>条件组合覆盖</td>
      <td>每个判定中各条件的每一种组合至少出现一次</td>
   </tr>
   <tr>
      <td>路径覆盖</td>
      <td>程序中每一条可能的路径至少执行一次</td>
   </tr>
   <tr>
      <td rowspan="4">循环覆盖</td>
      <td>简单循环</td>
      <td></td>
   </tr>
   <tr>
      <td>串接循环</td>
      <td></td>
   </tr>
   <tr>
      <td>嵌套循环</td>
      <td></td>
   </tr>
   <tr>
      <td>复杂循环</td>
      <td></td>
   </tr>
   <tr>
      <td>基本路径测试</td>
      <td>-</td>
      <td>根据程序流程图简化得控制流图，设计基本路径</td>
   </tr>
</table>

# 设计方法
## 示例代码

下面我将以这段代码为例（咱们先不管这个举例是否特别合适，能达到目的即可），带领大家一起体验白盒测试的各种方法。如果对java不太了解的童鞋，可以简单的理解为一个条件判断语句：如果满足条件A，c=x/y，否则满足条件B，c=c+1，最后条件都不满足的话，c=y+c。

建议：如果想使得测试思路更加清晰的话，可以自己在脑海里画一个二维坐标，x对应横轴，y对应纵轴。

```java
   public static float test(float x, float y) {

       float c = 0;
       if (x > 0 && y > 0) {
           c = x / y;
       }
       if (x > 1 || y < 5) {
           c = c + 1;
       }
       c = y + c;
       return c;
   }
```
## 语句覆盖
语句覆盖法的基本思想是设计若干测试用例，执行被测程序，使得每个可执行语句至少被执行一次。

- 如果是顺序结构，就让程序从头执行到尾
- 如果有分支，条件和循环，利用如下方法，执行足够的测试覆盖全部语句
### 设计用例

![这里写图片描述](https://cdn.jsdelivr.net/gh/amosnothing/cdn/image/software-test-4/20180505165131351.png)

`设计一条用例即可达到语句覆盖`

x = 2, y = 3

为什么? 因为整个方法体内，代码全部都被覆盖到了。想想是不是?

### 优缺点

优点
> 可以直观的从源代码得到测试用例，无需细分每条判定表达式。

缺点
> 由于这种测试方法仅仅针对程序逻辑中显式存在的语句，但对于隐藏条件是无法测试到的。比如在多分支的逻辑运算中无法全面的考虑。语句覆盖是最弱的逻辑覆盖。

## 判定覆盖
判定覆盖的基本思想是设计若干测试用例，运行被测程序，使得程序每个判断的取真分支和取假分支至少执行一次，即判断真假值均被满足。

一个判定往往代表程序的一个分支，所以判定覆盖也称为`分支覆盖`。
### 设计用例
![这里写图片描述](https://cdn.jsdelivr.net/gh/amosnothing/cdn/image/software-test-4/20180505171552977.png)

根据定义，我们将条件M的yes分支和no分支，条件N的yes分支和no分支覆盖到即可达到覆盖所有判定的真假分支。

| 用例    | 覆盖点           |
| ------- | ---------------- |
| x=2,y=4 | 覆盖M-yes，N-yes |
| x=0,y=7 | 覆盖M-no，N-no   |

### 优缺点
优点
> 判定覆盖具有与语句覆盖更强的测试能力。同样判定覆盖具有和语句覆盖一样的简单性，无需细分每个判定就可以得到测试用例。

缺点
> 往往大部分的判定语句是由多个逻辑条件组合而成（如，判定语句中包含AND、OR、CASE），若仅仅判断其整个最终结果，而忽略每个条件的取值情况，必然会遗漏部分测试路径。

## 条件覆盖
![这里写图片描述](https://cdn.jsdelivr.net/gh/amosnothing/cdn/image/software-test-4/2018050517370968.png)
条件覆盖要求设计足够多的测试用例，使得判定中的每个条件获得各种可能的结果，即每个条件至少有一次为真值，有一次为假值。
比如：x > 0 && y > 0
需要设计用例覆盖到 x>0为真/假 和 y>0为真/假的情况。

### 设计用例
<table border="1"><tr><td>判定条件</td><td>条件</td><td>取值</td><td>简称</td></tr><tr><td rowspan="4">M</td><td rowspan="2">x>0</td><td>TRUE</td><td>T1</td></tr><tr><td>FALSE</td><td>F1</td></tr><tr><td rowspan="2">y>0</td><td>TRUE</td><td>T2</td></tr><tr><td>FALSE</td><td>F2</td></tr><tr><td rowspan="4">N</td><td rowspan="2">x>1</td><td>TRUE</td><td>T3</td></tr><tr><td>FALSE</td><td>F3</td></tr>
<tr><td rowspan="2">y&lt; 5</td><td>TRUE</td><td>T4</td></tr><tr><td>FALSE</td><td>F4</td></tr></table>
我们现在需要做的是，用例覆盖到T1,T2,T3,T4,F1,F2,F3,F4

| 测试用例 | 具体条件           | 覆盖条件    |
| -------- | ------------------ | ----------- |
| x=2,y=-2 | x>0,y<=0,x>1,y<5   | T1,F2,T3,T4 |
| x=-1,y=6 | x<=0,y>0,x<=1,y>=5 | F1,T2,F3,F4 |


### 优缺点
优点
> 显然条件覆盖比判定覆盖，增加了对符合判定情况的测试，增加了测试路径。

缺点
> 要达到条件覆盖，需要足够多的测试用例，但条件覆盖并不能保证判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果。

## 判定-条件覆盖

它是`判定覆盖`和`条件覆盖`的交集，需要设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身所有可能结果也至少出现一次。

### 设计用例

![这里写图片描述](https://cdn.jsdelivr.net/gh/amosnothing/cdn/image/software-test-4/20180505182328217.png)

设计的用例满足:

- 覆盖T1-T4 ，F1-F4
- 覆盖M为真/假,N为真/假

| 测试用例 | 具体取值条件       | 取值条件    | 判定条件 | 执行路径 |
| -------- | ------------------ | ----------- | -------- | -------- |
| x=1,y=5  | x>0,y>0,x<=1,y>=5  | T1,T2,F3,F4 | M=T,N=F  | 1-2-5    |
| x=0,y=0  | x<=0,y<=0,x<=1,y<5 | F1,F2,F3,T4 | M=F,N=T  | 1-3-4    |
| x=2,y=-2 | x>0,y<=0,x>1,y<5   | T1,F2,T3,T4 | M=F,N=T  | 1-3-4    |
### 优缺点
优点
> 判定/条件覆盖满足判定覆盖准则和条件覆盖准则，弥补了二者的不足。

缺点
> 判定/条件覆盖准则的缺点是未考虑条件的组合情况。

## 条件组合覆盖
要求设计足够多的测试用例，使得每个判定中条件结果的所有可能组合至少出现一次。
### 设计用例
按照条件组合覆盖的基本思想，对于前面的例子，我们把每个判断中的所有条件进行组合，设计`组合条件`如表所示，而我们设计的测试用例就要`包括所有的组合条件`

| 组合编号 | 覆盖条件取值 | 判定条件取值 | 判定-条件组合    |
| -------- | ------------ | ------------ | ---------------- |
| 1        | T1,T2        | M=T          | x>0,y>0,M为真    |
| 2        | T1,F2        | M=F          | x>0,y<=0.M为假   |
| 3        | F1,T2        | M=F          | x<=0,y>0.M为假   |
| 4        | F1,F2        | M=F          | x<=0,y<=0.M为假  |
| 5        | T3,T4        | N=T          | x>1,y<5. N为真   |
| 6        | T3,F4        | N=T          | x>1,y>=5,N为真   |
| 7        | F3,T4        | N=T          | x<=1,y<5, N为真  |
| 8        | F3,F4        | N=F          | x<=1,y>=5, N为假 |

| 测试用例  | 覆盖条件    | 覆盖判断 | 覆盖组合 | 覆盖路径 |
| --------- | ----------- | -------- | -------- | -------- |
| x=2,y=4   | T1,T2,T3,T4 | M=T，N=T | 1，5     | 1-2-4    |
| x=1,y=0   | T1,F2,F3,T4 | M=F,N=T  | 2，7     | 1-3-4    |
| x=0,y=6   | F1,T2,F3,F4 | M=F,N=F  | 3，8     | 1-3-5    |
| x=-1,y=-1 | F1,F2,F3,T4 | M=F,N=T  | 4，7     | 1-3-4    |
| x=4,y=5   | T1,T2,T3,F4 | M=F,N=T  | 1，6     | 1-2-4    |

可以看出实际上 1-2-5是未被覆盖到的。下一个方法会提到。

### 优缺点
优点
> 多重条件覆盖准则满足判定覆盖、条件覆盖和判定/条件覆盖准则。更改的判定/条件覆盖要求设计足够多的测试用例，使得判定中每个条件的所有可能结果至少出现一次，每个判定本身的所有可能结果也至少出现一次。并且每个条件都显示能单独影响判定结果。

缺点
> 线性地增加了测试用例的数量。

## 路径覆盖
设计所有的测试用例，用来覆盖程序中的所有可能的执行路径。
### 设计用例
请结合上一种方法进行分析：

| 测试用例  | 覆盖条件    | 覆盖判断 | 覆盖组合 | 覆盖路径 |
| --------- | ----------- | -------- | -------- | -------- |
| x=2,y=4   | T1,T2,T3,T4 | M=T，N=T | 1,5      | 1-2-4    |
| x=1,y=0   | T1,F2,F3,T4 | M=F,N=T  | 2,7      | 1-3-4    |
| x=0,y=6   | F1,T2,F3,F4 | M=F,N=F  | 3,8      | 1-3-5    |
| x=-1,y=-1 | F1,F2,F3,T4 | M=F,N=T  | 4,7      | 1-3-4    |
| x=4,y=5   | T1,T2,T3,F4 | M=F,N=T  | 1,6      | 1-2-4    |
| x=0.5,y=3 | T1,T2,F3,F4 | M=T,N=F  | 1,8      | 1-2-5    |

### 优缺点
优点
> 可以对程序进行彻底的测试，比前面五种的覆盖面都广

缺点
> 需要设计大量，复杂的测试用例，使得工作量呈指数级增长，不见得把所有的条件组合都覆盖。